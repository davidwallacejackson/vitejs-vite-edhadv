// NOTE: ideally we'd do this in TS inside the src folder, but a service
// worker must always have the exact same name, and that requires tricky
// Vite/Rollup config. Since we don't actually need access to any of our
// other code here,it's easier to just do this in JS and treat it as a
// "static asset"

// if we were using TS, we'd type `self` to allow using it; since we're not
// we have to tell eslint to allow it
/* eslint-disable no-restricted-globals */

// matches hashed asset paths as generated by Vite/Rollup, e.g. /assets/SomeModule.abcd1234.js
// for more examples see: https://regex101.com/r/xJk6C8/1
const retryRegexProd = /\/assets\/\w+\.\w{8}\.(js|ts)x?$/;

// this is a regex that matches assets in dev -- leaving it in
// here in case anyone needs to test the retry behavior locally
// (if you do, you should also look for `chaosMonkey` in vite.config.ts)
// const retryRegexDev = /\/src\/.+\.(js|ts)x?$/;

const retryRegex = retryRegexProd;

const maxRetries = 5;
const initialBackoff = 100;
const maxBackoff = 1000;

self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim());
  console.log('JS retry proxy active');
});

async function wait(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms);
  });
}

/**
 * Makes a request, retrying several times in cases of network error. If all
 * retries fail, the error from the last attempt will be  thrown.
 *
 * Does not retry on user error (status 4xx), and does not implement any caching
 * (requests will still be automatically cached per their Cache-Control headers).
 */
async function fetchWithRetry(request) {
  let caughtErr;

  let backoff = initialBackoff;
  for (let i = 0; i < maxRetries; i++) {
    try {
      caughtErr = null;
      // requests here will already be prefixed, because they're intercepted from
      // the rest of the app, so it's OK to call fetch() without a prefix:

      // eslint-disable-next-line wandb/no-unprefixed-urls
      return await fetch(request);
    } catch (e) {
      console.warn(
        `${request.url}: fetch failed with network error (${
          i + 1
        } / ${maxRetries})`
      );
      caughtErr = e;
    }

    await wait(backoff);

    backoff = Math.min(backoff * 2, maxBackoff);
  }

  // this handles the case where the last retry resulted in a network
  // error -- in this case, caughtErr is guaranteed to be populated
  throw caughtErr;
}

self.addEventListener('fetch', (event) => {
  if (retryRegex.test(event.request.url)) {
    event.respondWith(fetchWithRetry(event.request));
  }
});
